# СОЗДАТЬ рабочие данные для дня 3 по примеру день1 и день2

Описание задания:

```
День 3: FastAPI — ваш новый Express/NestJS
Задача: Создать простой веб-сервер на Python. Это свяжет ваш бэкенд-опыт с новым языком.
Что делать:
Установите FastAPI: pip install "fastapi[all]".
Создайте простейший API в main.py:
python
from fastapi import FastAPI

app = FastAPI()

@app.get("/")
def read_root():
    return {"Hello": "World"}

@app.get("/items/{item_id}")
def read_item(item_id: int, q: str | None = None):
    return {"item_id": item_id, "q": q}

Запустите сервер: uvicorn main:app --reload.
Откройте http://127.0.0.1:8000/docs. Вы увидите автоматически сгенерированную документацию OpenAPI (Swagger). Это киллер-фича FastAPI, которая вам понравится.
```

Дополнить и расширить на твое усмотрение!
Подойти творчески!

Конечно! День 3 — это ключевой момент, где ваш опыт с Express/NestJS напрямую переносится в мир Python. FastAPI был создан с оглядкой на лучшие практики Node.js, так что вы почувствуете себя как дома, но с приятными "питоническими" бонусами.

Давайте творчески расширим предложенный план и создадим не просто "Hello World", а осмысленный API на основе нашей работы за предыдущие дни.

### План на День 3: От скрипта к полноценному API на FastAPI

1. **Задача 1: "Двигатель запущен!"**. Устанавливаем FastAPI и запускаем наш первый веб-сервер.
2. **Задача 2: "Магия из коробки"**. Исследуем автоматическую документацию — киллер-фичу FastAPI.
3. **Задача 3: "Оживляем пользователей"**. Перенесем нашу логику обработки пользователей из скриптов в полноценные API эндпоинты.

**Подготовка**: следуя нашей лучшей практике, давайте зафиксируем вчерашнюю работу в Git.

```bash
# Убедитесь, что вы добавили все изменения Дня 2
git add main.py requirements.txt

# Создаем коммит, который будет нашей точкой сохранения
git commit -m "feat: Complete Day 2 - functions and API requests"
```

Теперь можно смело изменять `main.py` для задач третьего дня!

### Задача 1: "Двигатель запущен!" — Установка и первый запуск

FastAPI, как и Express, не является частью стандартной библиотеки Python. Его нужно установить.
Также нам понадобится ASGI-сервер `Uvicorn`, который будет запускать наше приложение.

**Аналогия**: FastAPI — это ваш Express/NestJS. `Uvicorn` — это среда выполнения, как сам Node.js, который исполняет ваш `server.js`.

1. **Установка**. В вашем активном `.venv` окружении выполните команду:

```bash
# `[all]` установит FastAPI, uvicorn и другие полезные зависимости
pip install "fastapi[all]"
```

2. **Обновление зависимостей**. Сразу зафиксируем новую библиотеку в нашем файле:

```bash
pip freeze > requirements.txt
```

3. **Первый код API**. Замените все содержимое файла `main.py` на этот код:

```python
# main.py

# 1. Импортируем класс FastAPI. Аналог: import express from 'express';
from fastapi import FastAPI

# 2. Создаем экземпляр приложения. Аналог: const app = express();
app = FastAPI(
    title="My First API",
    description="This is a demo API for learning FastAPI, created by a Node.js developer!",
    version="0.1.0",
)

# 3. Создаем маршрут (route) для корневого URL.
# Декоратор `@app.get("/")` связывает URL и HTTP-метод GET с функцией ниже.
# Это прямой аналог app.get('/', (req, res) => { ... });
@app.get("/")
def read_root():
    """
    Этот эндпоинт возвращает приветственное сообщение.
    Вся документация из docstring будет видна в /docs!
    """
    # 4. FastAPI автоматически конвертирует словарь Python в JSON-ответ.
    # Аналог: res.json({ "message": "Hello from your first FastAPI server!" });
    return {"message": "Hello from your first FastAPI server!"}

```

4. **Запуск сервера**. В терминале выполните команду:

```bash
# uvicorn [имя_файла]:[переменная_app] --reload
uvicorn main:app --reload
```

    * `uvicorn`: Команда для запуска сервера.
    * `main:app`: Путь к вашему приложению. `main` — это файл `main.py`, а `app` — это переменная `app = FastAPI()`.
    * `--reload`: Ключевая опция для разработки. Это ваш **`nodemon`** — сервер будет автоматически перезагружаться при сохранении изменений в коде.

Вы увидите вывод, сообщающий, что сервер запущен по адресу `http://127.0.0.1:8000`. Откройте его в браузере!

### Задача 2: "Магия из коробки" — Автоматическая документация

Это момент, когда вы поймете всю мощь FastAPI и типизации в Python.

1. **Откройте документацию**. Не закрывая сервер, перейдите в браузере по адресу **http://127.0.0.1:8000/docs**.
2. **Что вы видите?** Перед вами полностью интерактивная документация OpenAPI (Swagger UI), сгенерированная автоматически на основе вашего кода. Вы можете видеть эндпоинты, их описание (взятое из docstring!), и даже выполнять тестовые запросы прямо из браузера.

Давайте добавим более сложный эндпоинт, чтобы увидеть документацию в действии.

**Добавьте этот код в `main.py`:**

```python
# ... после первого эндпоинта

@app.get("/items/{item_id}")
def read_item(item_id: int, q: str | None = None):
    """
    Получает товар по его ID.
    - **item_id**: ID товара (обязательный параметр пути).
    - **q**: Поисковый запрос (опциональный параметр запроса).
    """
    # FastAPI автоматически валидирует `item_id`. Если передать не число, будет ошибка.
    # `q` - опциональный параметр. Если его нет, он будет равен `None`.
    # Это похоже на `const { item_id } = req.params; const { q } = req.query;`

    response_data = {"item_id": item_id}
    if q:
        response_data["q"] = q

    return response_data
```

**Разбор нового эндпоинта:**

* **`{item_id}`**: Параметр пути (path parameter).
* **`item_id: int`**: А вот и магия. Мы указываем, что `item_id` должен быть целым числом (`int`). FastAPI будет:

1. **Валидировать** входящие данные. Попробуйте в документации передать "abc" — вы получите красивую ошибку `422 Unprocessable Entity`.
2. **Преобразовывать** тип. Строка `"123"` из URL будет автоматически превращена в число `123` в вашей функции.
3. **Документировать** это требование в `/docs`.
* **`q: str | None = None`**: Параметр запроса (query parameter).
    * `q: str`: Мы ожидаем строку.
    * `| None`: Она также может быть `None` (питонический `null`).
    * `= None`: Значение по умолчанию делает параметр опциональным.

Обновите страницу `/docs`, и вы увидите новый эндпоинт со всеми параметрами.

### Задача 3: "Оживляем пользователей" — Создаем Users API

Давайте объединим все наши знания и создадим API для работы с пользователями, которых мы обрабатывали в первый день.

**Замените код в `main.py` на этот финальный вариант для Дня 3:**

```python
# main.py

from fastapi import FastAPI, HTTPException

app = FastAPI(
    title="User Management API",
    description="An API to manage users, built with FastAPI.",
    version="1.0.0",
)

# --- База данных (в виде простого списка словарей) ---
# В реальном проекте это будет идти из PostgreSQL, MongoDB и т.д.
DB_USERS = [
    {"id": 1, "name": "Alice", "role": "premium"},
    {"id": 2, "name": "Bob", "role": "free"},
    {"id": 3, "name": "Charlie", "role": "admin"},
    {"id": 4, "name": "Diana", "role": "premium"},
]

# --- Эндпоинты ---

@app.get("/")
def read_root():
    """Корневой эндпоинт с приветствием."""
    return {"message": "Welcome to the User Management API!"}


@app.get("/users")
def get_all_users():
    """Возвращает список всех пользователей в системе."""
    return {"users": DB_USERS}


@app.get("/users/{user_id}")
def get_user_by_id(user_id: int):
    """
    Находит и возвращает одного пользователя по его ID.
    Если пользователь не найден, возвращает ошибку 404.
    """
    # Используем 'list comprehension' из Дня 1, но можно и простой цикл
    found_user = next((user for user in DB_USERS if user["id"] == user_id), None)

    if not found_user:
        # Аналог: return res.status(404).json({ message: "User not found" });
        raise HTTPException(
            status_code=404,
            detail=f"User with ID {user_id} not found"
        )

    return {"user": found_user}

```

**Что здесь нового и важного:**

* **Имитация БД**: Мы создали список `DB_USERS`, чтобы наш API мог работать с данными.
* **Эндпоинт `/users`**: Простой GET-запрос, который возвращает весь список.
* **Эндпоинт `/users/{user_id}`**:
    * `next((... for ...), None)`: Это эффективный "питонический" способ найти первый элемент в списке, который удовлетворяет условию, или вернуть `None`, если ничего не найдено.
    * `raise HTTPException`: Стандартный способ в FastAPI вернуть ошибку с нужным HTTP-статусом и сообщением. Это гораздо чище, чем вручную управлять объектом ответа.

Теперь снова запустите сервер (`uvicorn main:app --reload`), откройте `/docs` и поиграйте с вашим новым API! Попробуйте получить всех пользователей, одного конкретного пользователя, а также запросить несуществующий ID, чтобы увидеть красивую ошибку 404.

### Итог Дня 3

Вы совершили гигантский скачок! Теперь вы можете:

* Создавать базовые веб-серверы на FastAPI.
* Описывать эндпоинты с помощью декораторов.
* Использовать мощь **типизации Python** для автоматической валидации и документации.
* Работать с параметрами пути и запроса.
* Возвращать как успешные JSON-ответы, так и стандартные HTTP-ошибки.

Вы практически "портировали" свои знания Express/NestJS в Python, и теперь готовы к следующему шагу: подключению LangChain, чтобы сделать ваш API по-настоящему интеллектуальным.

