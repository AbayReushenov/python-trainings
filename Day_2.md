# ПРОДОЛЖИМ ИЗУЧЕНИЕ Python
## ДЕНЬ 2
ОПИСАНИЕ ЧТО НУЖНО ИЗУЧИТЬ

```
День 2: Функции, модули и зависимости
Задача: Понять, как структурируется код и как управлять зависимостями.
Что делать:
Напишите несколько функций в main.py. Обратите внимание на синтаксис def my_function(arg1, arg2):.
Познакомьтесь с pip. В активированном окружении выполните pip install requests. Это аналог npm install axios.
Создайте файл requirements.txt и добавьте в него requests. Теперь другой разработчик сможет установить все зависимости командой pip install -r requirements.txt.
Используйте requests, чтобы сделать GET-запрос к любому публичному API. import requests — это ваш import ... from ....
```

Я продолжу в той же директории что было в ДЕНЬ 1 и где есть все настройки первого дня.

СОЗДАЙ ТАКОЙ ЖЕ ПОДРОБНЫЙ ПЛАН ОБУЧЕНИЯ.

Отлично, продолжаем! День 2 посвящен структурированию кода и взаимодействию с внешним миром — две абсолютно привычные для вас задачи. Мы перенесем логику из первого дня в переиспользуемые функции и научимся "достукиваться" до внешних API, как вы это делали с `axios` или `fetch`.

### План на День 2: Функции, модули и API-запросы

1. **Задача 1: Рефакторинг с помощью функций**. Превратим наш вчерашний скрипт в набор логических, переиспользуемых блоков.
2. **Задача 2: Установка внешней зависимости**. Познакомимся с `pip`, установим библиотеку `requests` для HTTP-запросов и зафиксируем зависимости.
3. **Задача 3: Взаимодействие с внешним API**. Напишем функцию, которая делает реальный GET-запрос в интернет и обрабатывает полученные данные.

Мы продолжим работать в том же файле `main.py` из первого дня.

### Задача 1: Рефакторинг кода с помощью функций

Сейчас наш `main.py` — это один сплошной скрипт. Это нормально для прототипа, но плохая практика для растущего приложения. Давайте вынесем логику в функции.

**Откройте ваш файл `main.py` и замените его содержимое на это:**

```python
# main.py

# --- Шаг 1: Определение функций ---

def process_users(user_list):
    """
    Анализирует список пользователей, выводит приветствия для "важных"
    и возвращает список их имен.

    Аналог в JS: const processUsers = (userList) => { ... };
    """
    print("\nАнализ пользователей:")

    important_names = []
    for user in user_list:
        is_premium = user["role"] == "premium"
        is_admin = user["role"] == "admin"

        if is_premium or is_admin:
            greeting = f"✅  Здравствуйте, {user['name']}! Ваш статус: {user['role']}."
            print(greeting)
            important_names.append(user["name"]) # .append - это аналог .push()
        else:
            message = f"   Пользователь {user['name']} имеет базовый доступ."
            print(message)

    return important_names


def main():
    """
    Главная функция, точка входа в нашу программу.
    """
    project_title = "Скрипт обработки пользователей v2.0"
    print(f"--- Запуск: {project_title} ---")

    users = [
        {"id": 1, "name": "Alice", "role": "premium", "logins": 95},
        {"id": 2, "name": "Bob", "role": "free", "logins": 23},
        {"id": 3, "name": "Charlie", "role": "admin", "logins": 150},
        {"id": 4, "name": "Diana", "role": "premium", "logins": 110}
    ]

    # Вызываем нашу первую функцию и сохраняем результат
    processed_names = process_users(users)
    print(f"\nСписок важных пользователей: {processed_names}")

    print("\n--- Анализ завершен ---")


# --- Шаг 2: Точка входа в скрипт ---
# Эта конструкция гарантирует, что код внутри `main()` будет вызван
# только при прямом запуске файла `python main.py`.
# Это стандартная и очень распространенная практика в Python.
if __name__ == "__main__":
    main()

```

**Что мы сделали и почему это важно:**

* **Инкапсуляция**: Мы вынесли всю логику по обработке пользователей в функцию `process_users`. Теперь она не зависит от глобальных переменных, а принимает данные через аргумент `user_list`. Это делает код тестируемым и переиспользуемым.
* **Точка входа `if __name__ == "__main__":`**: Это канонический способ организации запускаемого Python-скрипта. Он говорит: "Если этот файл запустили напрямую, а не импортировали в другой файл, то выполни эту функцию `main()`". Это позволяет безопасно импортировать функции из этого файла в другие части вашего проекта в будущем, не опасаясь, что весь код выполнится при импорте.

Запустите скрипт (`python main.py`) и убедитесь, что результат остался прежним.

### Задача 2: Управление зависимостями (`pip` и `requests`)

Пришло время выйти в интернет. В мире Node.js для этого есть `axios` или встроенный `fetch`. В Python золотым стандартом для HTTP-запросов является библиотека **`requests`**.

1. **Установка `requests`**. Убедитесь, что ваше виртуальное окружение (`.venv`) активно (в терминале должна быть приписка `(.venv)`). Выполните команду:

```bash
# аналог `npm install requests` или `yarn add requests`
pip install requests
```

`pip` — это менеджер пакетов Python. Он скачал библиотеку `requests` и все ее зависимости (другие библиотеки, от которых она зависит) прямо в вашу папку `.venv/lib/...`.
2. **Создание `requirements.txt`**. Теперь нам нужно зафиксировать наши зависимости, чтобы другой разработчик (или сервер на Render.com) знал, что нужно установить.

```bash
# аналог `npm list --depth=0` и записи в package.json
pip freeze > requirements.txt
```

Эта команда берет все пакеты, установленные в вашем окружении, и записывает их точные версии в файл `requirements.txt`. Откройте его, и вы увидите что-то вроде:

```
certifi==2024.7.4
charset-normalizer==3.3.2
idna==3.7
requests==2.32.3
urllib3==2.2.2
```

**Ключевое отличие от `package.json`**: `requirements.txt` — это "плоский" список всех-всех зависимостей. `pip` не имеет встроенного разделения на `dependencies` и `devDependencies`, как `npm`. Для этого используются отдельные файлы (например, `requirements-dev.txt`), но для наших целей достаточно одного.

### Задача 3: Первый API-запрос

Теперь, когда `requests` установлен, давайте используем его. Мы напишем функцию, которая обращается к публичному API `https://api.jsonserve.com/` для получения "случайных" данных.

**Добавьте новую функцию в `main.py` и вызовите ее из `main()`:**

```python
# main.py

# В самом верху файла добавьте импорт
# Аналог: import requests from 'requests'; (хотя синтаксис проще)
import requests

# ... (здесь ваша функция process_users)
def process_users(user_list):
    # ... без изменений
    pass

def get_random_data():
    """
    Делает GET-запрос к публичному API и возвращает данные.
    """
    print("\nПолучение внешних данных...")
    api_url = "https://api.jsonserve.com/bRZJAw" # Простое JSON API для примера

    try:
        # Аналог: const response = await axios.get(api_url);
        response = requests.get(api_url)

        # Проверяем, что запрос прошел успешно (статус 2xx)
        response.raise_for_status() # Если статус 4xx или 5xx, вызовет ошибку

        # .json() парсит JSON-ответ в питоновский словарь (dict)
        # Аналог: const data = response.data;
        data = response.json()
        print("✅ Данные с API успешно получены!")
        return data

    except requests.exceptions.RequestException as e:
        # Обработка ошибок сети, таймаутов и т.д.
        print(f"❌ Ошибка при запросе к API: {e}")
        return None


def main():
    """
    Главная функция, точка входа в нашу программу.
    """
    project_title = "Скрипт обработки пользователей v2.0"
    print(f"--- Запуск: {project_title} ---")

    # ... (код с определением списка users)
    users = [
        {"id": 1, "name": "Alice", "role": "premium", "logins": 95},
        # ...
    ]

    processed_names = process_users(users)
    print(f"\nСписок важных пользователей: {processed_names}")

    # Вызываем нашу новую функцию
    external_data = get_random_data()
    if external_data:
        # Работаем с полученными данными
        title = external_data.get("title", "Заголовок не найден")
        print(f"Полученный заголовок из API: '{title}'")


    print("\n--- Анализ завершен ---")


if __name__ == "__main__":
    main()

```

**Разбор новой функции `get_random_data`:**

* **`import requests`**: Мы импортируем всю библиотеку. Теперь мы можем обращаться к ее функциям через точку: `requests.get()`.
* **`requests.get(api_url)`**: Простой и понятный вызов GET-запроса. Возвращает объект ответа.
* **`try...except`**: Блок для обработки ошибок. Это аналог `try...catch` в JS. Если что-то пойдет не так с запросом (нет сети, сервер вернул ошибку 500), выполнение перейдет в блок `except`.
* **`response.raise_for_status()`**: Удобный метод, который проверяет код ответа. Если код 200-299, он ничего не делает. Если это код ошибки (4xx, 5xx), он генерирует исключение, которое будет поймано нашим `except`.
* **`response.json()`**: Этот метод делает то же самое, что и `.data` в `axios` — парсит тело ответа из формата JSON в нативные структуры данных Python (в данном случае, в `dict`).

Теперь запустите `python main.py`. Вы должны увидеть сначала результат обработки ваших локальных пользователей, а затем сообщение об успешном получении данных и заголовок из внешнего API.

### Итог Дня 2

Поздравляю! Вы сделали огромный шаг вперед:

* Вы научились структурировать код с помощью **функций**, что является основой для любого фреймворка, включая FastAPI.
* Вы освоили **`pip`** и `requirements.txt` — ключевые инструменты для управления зависимостями в любом Python-проекте.
* Вы сделали свой первый **API-запрос**, получив данные из внешнего мира.

Теперь вы готовы к самому интересному — сборке всех этих частей в единый веб-сервис на FastAPI.

